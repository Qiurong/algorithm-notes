### 旋转数组系列

旋转数组是指把一个完全升序的数组切割成两个完全升序的数组，然后把这个两个数组的顺序颠倒过来。

#### 寻找旋转排序数组中的最小值

一般而言有序数组都遵循着 `a[mid]` < `a[end]`，但旋转数组中存在 `a[mid]` > `a[end]`(因为`a[end]`有可能是被旋转而来的部分升序数组)。抓住`[mid]`与`[end]`之间的大小关系就能判断二分查找中往左还是往右走。

数组原本是[start, end]严格升序。

- `a[mid] > a[end]`：[start, mid]严格升序，最小值在[**mid + 1**, end]之间。
- `a[mid] < a[end]`：[mid, end]严格升序，最小值在[start, **mid**]之间。(可能就是`[mid]`)

升级版就是数组中多了重复值之后，最简单的思想就是缩小区间(`end--`)，因为在剩下的区间中找到相等的值。

#### 搜索旋转排序数组

开始的想法肯定是二分查找，二分查找是比较`[mid]`与`target`的值然后决定向左向右走。同理这题的第一层循环条件也是比较`[mid]`与`target`。

- 第一层：比较`[mid]`与`target`的值。

  - [mid] == target：直接return。

  - [mid] < target：去往比[mid]大的部分
  - [mid] > target：去往比[mid]小的部分

- 第二层：根据 `[end]` 与 `[mid]` 之间的关系来判断。
  - [end] < [mid]：[start, mid]严格升序，最小值在后半部分，在[mid, mini, mini + 1, end]。且[end] < [start]。把整个数组按照严格升序来排序是：{[mini, end], [start, mid], [mid, mini -1]}
  - [end] > [mid]：[mid, end]严格升序，最小值在前半部分，在[start, mini, mini + 1, mid]。且 [end] < [start]。把整个数组按照严格升序来排序是：{[mini, mid], [mid, end], [start, mini -1]}

- 第三层：再去比较`target`与`end`之间的值从而分情况讨论。

升级版就是数组多了重复值之后，类似于上面的思想：遇到相同的直接把`end`删掉。